# -*- coding: utf-8 -*-
"""Another copy of Version 2: Windward App Building Blocks.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JAwUNFNiBRk3iexLOowckVoMHyIpi6Yb
"""

import sys
# The original path was for a Google Colab environment.
# updated it to the right location on my mac
path = "/Users/diegoanderson/Desktop/Honors Software Engineering"
sys.path.insert(0,path)

import my_windward_app.weekly_rotation_data as weekly_rotation_data
import my_windward_app.weekly_misc_data as weekly_misc_data
from flask import Flask, jsonify, request
import datetime as dt # this helps us work with dates and times
import sqlite3 #speak SQLite

ROTATIONS = weekly_rotation_data.weekly_rotations
MISC = weekly_misc_data.weekly_misc

assert len(ROTATIONS) == len(MISC)

# flask setup, setting up our "team"
app = Flask(__name__)
# =====
USER_ROSTER = {
  "secret-token-123": {"name": "Diego Anderson", "role": "student", "id": 1},
  "another-secret-token-456": {"name": "Steve Kerr", "role": "coach", "id": 2}
}

# database helper
# this function connects to our database.db file and returns the connection
# the 'row_factory' line is a pro-move. it makes the database return rows that
# act like dictionaries, so we can access data by column name
def get_db_connection():
  conn = sqlite3.connect('database.db')
  conn.row_factory = sqlite3.Row
  return conn

my_test_date = dt.date(2025,10,13)
my_test_date2 = dt.date(2025,11,13)

time_diff = my_test_date2 - my_test_date

print(f"the date type of time_diff {type(time_diff)}")
print(time_diff)
print(time_diff.days)

# This function helps figure out if the year is 2025 or 2026 based on the month, kind of like figuring out which school year it is
def get_year_from_schedule(m):
  # If the month (m) is before August (month 8)...
  if m < 8:
    return 2026 # ...then it's for the 2026 part of the school year, like the spring semester
  else:
    return 2025 # ...otherwise, it's for the 2025 part of the school year, like the fall semester

# This function checks if the second date (m2/d2) is within 7 days (1 week) of the first date (m1/d1). useful for checking if something's in the same week
def within_a_week_of(m1,d1,m2,d2):
  # Remember: you can subtract two date objects to find the difference in time!
  # If you add .days to the result, you get the number of days difference.

  # Let's figure out the full dates (including the year) for both dates.
  year_date1 = get_year_from_schedule(m1) # Get the year for the first date, using our function
  year_date2 = get_year_from_schedule(m2) # Get the year for the second date, using the same function
  date1 = dt.date(year_date1,m1,d1) # Make a date object for the first date
  date2 = dt.date(year_date2,m2,d2) # Make a date object for the second date

  # Calculate the difference between the two dates.
  time_difference = date2 - date1

  # Check if the difference in days is less than 7 AND not a negative number (meaning date2 is not before date1).
  if time_difference.days < 7 and time_difference.days >= 0:
    return True # If it's within 7 days (and not before), return True
  else:
    return False # Otherwise, return False

def get_week_rotation(m,d):
  """given a valid month [1-12] and date [1-31] return the rotation element that contains the date.
  The day should be a school day otherwise return None."""

  # Loop through each week in our ROTATIONS data.
  for idx,(month,date,blocks,off) in enumerate(ROTATIONS):
    # Check if the date we're looking for (m, d) is in this week.
    if within_a_week_of(month,date,m,d):
      # We found the correct week. Now, let's handle days off.
      # The original function had duplicated and broken logic here.
      # This corrected version finds the week and returns its data.
      # The logic to handle days off is better placed in get_rotation_for_date.
      # For now, we just return the raw data for the found week.
      
      # The code below this was attempting to modify the blocks, but it was
      # outside the `if` check and had syntax errors.
      # The correct approach is to find the week first, then process it.
      _blks = blocks[:] # Make a copy to avoid changing the original list.
      if off is not None:
          # This is where you would insert None for days off if needed.
          pass # For now, we'll just return the original week data.
      return ROTATIONS[idx]

  return None # if we don't find a week, return None

get_week_rotation(10,15) # expect this to come back [10,13,     [3, 4, 5, 6,  1],None]
#get_week_rotation(12,25) # expect None, because it's christmas
get_week_rotation(10,1) # expect [9,29, [6, 1, 2, 3],4]

rotation1 = get_week_rotation(9,15)
rotation2 = get_week_rotation(10,15)
rotation1[0],rotation2[0]
ROTATIONS[3:7]

DAY_NAME = ["mon","tue","wed","thu","fri"] # This is a list of the school days of the week

def get_rotation_for_date(m,d):
  """
  give it a month (m) and a day (d), and it tells you:
  1. What school block you have on that day.
  2. What day of the week it is (like Monday or Tuesday).
  If it's a day with no school (like a holiday or weekend), it says "None".
  """

  # First, check if this date is a special day off (like a holiday) from our MISC list
  for misc_date in MISC:
      # If the month and day match a date in the MISC list...
      if misc_date[0] == m and misc_date[1] == d:
          return None # ...then it's a day off, so we say "None"

  # If it's not a special day off, let's find which school week this date is in
  rotations = get_week_rotation(m,d)
  # If this date doesn't fall into any of our scheduled school weeks...
  if rotations is None:
    return None # ...then it's not a school day we have a rotation for, so we say "None"

  # If we found a school week, let's get the details for that week
  month,date,blocks,days_off = rotations # Unpack the weekly data.

  # *** FIX: Adjust the schedule for days off ***
  # Make a copy of the blocks so we don't change the original data.
  adjusted_blocks = list(blocks) 
  if days_off is not None:
    # If 'days_off' is a single number (like 1 for Monday)...
    if isinstance(days_off, int):
      # ...insert None at that position (adjusting for 0-based index).
      adjusted_blocks.insert(days_off - 1, None)
    # If 'days_off' is a list of numbers (like [1, 4] for Mon & Thu)...
    elif isinstance(days_off, list):
      for day_index in sorted(days_off, reverse=True): # Sort reverse to not mess up indices
        adjusted_blocks.insert(day_index - 1, None)

  # Now, let's figure out how many school days away the date we asked about is
  # We need to know the year for both the start of the rotation week and the date we asked about
  year_date2 = get_year_from_schedule(m) # Get the year for the date we asked about
  year_date1 = get_year_from_schedule(month) # Get the year for the start of the rotation week
  date2 = dt.date(year_date2,m,d) # Make a date object for the date we asked about
  date1 = dt.date(year_date1,month,date) # Make a date object for the start of the rotation week

  days_diff = (date2 - date1).days # Calculate the difference in days between the two dates

  # IMPORTANT CHECK: Make sure the number of days difference is like a school day (0 to 4, for Mon-Fri)
  # If it's less than 0 (date is before the rotation week starts) or more than 4 (like a weekend day relative to the start)...
  if days_diff < 0 or days_diff > 4:
      return None # ...then it's not a regular school day in this rotation, so we say "None"

  # If we made it this far, it's a school day with a block
  # Use the days_diff number to pick the right block from the 'blocks' list (0 is the first day, 1 is the second, etc.)
  # Use the same days_diff number to pick the right day name from the 'DAY_NAME' list
  return ( adjusted_blocks[days_diff],DAY_NAME[days_diff] ) # Give back the block number and the day name

# creating our first play (api endpoint)
# this is a flask route, its a decorator that tells our app:
# when someone visits a url that looks like /api/rotation/some-month/some-day run this function
# the <int:month> and <int:day> parts are variables captured from the URL
@app.route("/api/rotation/<int:month>/<int:day>")
def api_get_rotation(month, day):
  # this is the api endpoint function, it calls our original logic and formats the output for the web
  #still gotta run our original function with the month and day from the URL
  rotation_info = get_rotation_for_date(month,day)

  if rotation_info and rotation_info[0] is not None:
    # if we get a result, return it as JSON, which is the standard language of APIs, kinda looks like a python dictionary
    #jsonify() is a flask helper that creates a proper web response
    result = {"rotation": rotation_info[0], "day_of_week": rotation_info[1]}
    return jsonify(result)
  else:
    # if there aint no school, return a 404 not found error with ah helpful message
    error_message = {"error": "No school or rotation found for this date."}
    return jsonify(error_message), 404


@app.route("/api/profile")
def api_get_profile():
  provided_token = request.args.get('token')
  if not provided_token:
    return jsonify({"error": "Authentication token is required."}), 401
  user_profile = USER_ROSTER.get(provided_token)
  if user_profile:
    return jsonify(user_profile)
  else:
    return jsonify({"error": "invalid authentication token."}), 403

@app.route('/api/announcements', methods=['GET', 'POST'])
def api_announcements():
  # no matter what we need a connection to the databse
  conn = get_db_connection()

  if request.method == 'POST':
    # gotta get the data the user sent
    new_announcement = request.get_json()
    author = new_announcement['author']
    message = new_announcement['message']

    # use an SQL INSERT command to add the new note to the filing cabinet
    # the '?' are placeholders to prevent security issues (SQL Injection)
    conn.execute('INSERT INTO announcements (author, message) VALUES (?, ?)',
                 (author, message))
    
    # commit/save the changes to the database file
    conn.commit()
    conn.close()

    # return a "created" success message
    return jsonify({"message": "Announcement posted successfully!"}), 201
  
  # this part runs if the method is GET
  # use an SQL SELECT command to get all notes from the announcements drawer.
  posts = conn.execute('SELECT * FROM announcements').fetchall()
  conn.close()

  # 'fetchall()' returns a list of database rows. we need to convert them into a list
  # of simple dictionaries so jsonify can understand them.
  # this is a list comprehension, a powerful Python feature
  announcements_list = [dict(row) for row in posts]

  # return the list of all announcements
  return jsonify(announcements_list)

# Let's test our function with some dates:
print(get_rotation_for_date(10,15)) # Should tell us the block and day for Oct 15
print(get_rotation_for_date(1,16)) # Should say None because it's a special day off (in MISC)
print(get_rotation_for_date(9,2))  # Should tell us the block and day for Sep 2
print(get_rotation_for_date(10,18)) # Should say None because it's a weekend relative to its week
print(get_rotation_for_date(12,25)) # Should say None because it's Christmas (in MISC)

for r in ROTATIONS:
  if r[-1] is not None:
    if type(r[-1]) == type([]):
      print(r[-1],type(r[-1]))

type([])

# Write a function that will return the dates for a requested block within a range

# get block in range(6,9,15,10,15) --> returns ('mon', '9/15')
def get_blocks_in_range(target_rotation,m1,d1,m2,d2):
  year1 = get_year_from_schedule(m1)
  year2 = get_year_from_schedule(m2)
  start_date = dt.date(year1, m1, d1)
  end_date = dt.date(year2, m2, d2)

  if start_date > end_date:
    return [] # or raise an error for an invalid range
  results = []
  current_date = start_date
  while current_date <= end_date:
    rotation_info = get_rotation_for_date(current_date.month, current_date.day)
    if rotation_info and rotation_info[0] == target_rotation:
      results.append((f"{current_date.month}/{current_date.day}", rotation_info[1]))
    current_date += dt.timedelta(days=1)
  return results

print("\n--- testing get_blocks_in_range ---")
print(f"Dates for rotation 6 between 9/15 and 10/15: {get_blocks_in_range(6, 9, 15, 10, 15)}")
print(f"Dates for rotation 1 between 8/25 and 9/5: {get_blocks_in_range(1, 8, 25, 9, 5)}")

# starting the game
# regular way to say if this script is run directly and not imported, then start our web server
# debug = true helps auto-restart the server when you save the file and give you detailed erorr pages
if __name__ == '__main__':
  app.run(debug=True)
